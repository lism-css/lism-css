# gridでカラムがきれいに並ぶサイトを作る

要素の整列にはFlexとGridがありますが、実はGridの方が柔軟で便利な場面も多いものです。ただ慣れの差からFlex中心になりがちです。本セクションでは、Gridが苦手な方や習得したい方向けに、Flexとの比較を交えつつ基礎から応用まで実務的に解説します。


## 要素を2列に並べるカラムレイアウトの実装

要素を2列に並べるよくあるレイアウトを、FlexとGridで実装してみましょう。

まず、Gridで実装してみます。以下のコードでは、`display: grid`により要素を格子状に配置できるようにし、`grid-template-columns: repeat(3, 1fr);`で「幅を均等に3分割したカラムを3つ作る」という指定をしています。

このため、子要素は自動的に整列し、複雑な計算なしで均等カラムが完成します。`gap`で行・列のすべてのすき間をまとめて調整できるのもシンプルです。

```css
/* grid */
.grid-2cols {
  display: grid;
  gap: var(--space--4);
  grid-template-columns: 1fr 1fr;
}
```

```html
<!-- grid -->
<div class="grid-2cols">
  <div class="_box_">Box - A</div>
  <div class="_box_">Box - B</div>
  <div class="_box_">Box - C</div>
  <div class="_box_">Box - D</div>
</div>
```

次にFlexで実装してみます。以下のコードでは、`display: flex`と`flex-wrap: wrap`を組み合わせて横並び→折返しを可能にしています。

ただし「2列」にしたい場合、`flex-basis: calc(50% - gap)`のように 幅を自分で計算して指定する必要があります。Flexでは比率や列数を指定する概念がもともとないため、このように手動計算が増える点がGridとの大きな違いです。`flex-grow: 1`は各アイテムに空きスペースを均等に配分するための指定です。

```css
/* flex */
.flex-2cols {
  --gap: var(--space--4);
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
}
.flex-2cols > * {
  flex-basis: calc(50% - var(--gap));
  flex-grow: 1;
}
```

```html
<!-- flex -->
<div class="flex-2cols">
  <div class="_box_">Box - A</div>
  <div class="_box_">Box - B</div>
  <div class="_box_">Box - C</div>
  <div class="_box_">Box - D</div>
</div>
```


### カラム比率が2:1で並ぶレイアウト

前述したサンプルでは、カラムの比率が1：1で並んでいます。今度は、カラム比率が2:1で２列に並ぶようなレイアウトを組んでみましょう。

Gridでは、`grid-template-columns: 2fr 1fr`のように、列の比率をそのまま宣言するだけで2:1レイアウトが完成します。比率管理も余白管理も一括でおこなえるため、コードがシンプルで意図が明確です。

一方、Flexは列や比率の概念を持たないため、`flex-basis`に66.66% / 33.33%を自分で計算して指定し、`nth-child()`で項目を振り分ける必要があります。比率レイアウトについては、Gridの方が直感的で保守しやすいといえます。

```css
/* grid */
.grid-2\:1 {
  display: grid;
  gap: var(--space--4);
  grid-template-columns: 2fr 1fr;
}

/* flex */
.flex-2\:1 {
  --gap: var(--space--4);
  display: flex;
  flex-wrap: wrap;
  gap: var(--gap);
}
.flex-2\:1 > :nth-child(2n-1) {
  flex-basis: calc(66.66% - var(--gap));
  flex-grow: 1;
}
.flex-2\:1 > :nth-child(2n) {
  flex-basis: calc(33.33% - var(--gap));
  flex-grow: 1;
}
```

```html
<!-- grid -->
<div class="grid-2:1">
  <div class="_box_">Box - A</div>
  <div class="_box_">Box - B</div>
  <div class="_box_">Box - C</div>
  <div class="_box_">Box - D</div>
</div>

<!-- flex -->
<div class="flex-2:1">
  <div class="_box_">Box - A</div>
  <div class="_box_">Box - B</div>
  <div class="_box_">Box - C</div>
  <div class="_box_">Box - D</div>
</div>
```

<iframe height="300" style="width: 100%;" scrolling="no" title="book 1- grid / flex " src="https://codepen.io/ddryo-the-encoder/embed/RNaWWQR/6acf662f5fa38d0d54cd08c5c00531d6?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true">
  See the Pen <a href="https://codepen.io/ddryo-the-encoder/pen/RNaWWQR/6acf662f5fa38d0d54cd08c5c00531d6">book 1- grid / flex </a> by ddryo (<a href="https://codepen.io/ddryo-the-encoder">@ddryo-the-encoder</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>


## Gridでレイアウトで組むメリット

このように、よくあるカラムレイアウトをGridで組めるようになると以下のようなメリットを得られます。

- 親要素へのスタイリングだけ基本的に完結できるので、CSSのコードが少なくなる
- 比率調整も直感的で簡単（`flex-basis` の % を計算したりしなくていい）

「カラム数が増えたらコードが長くなるかも」と考える人もいるかもしれませんが、`repeat()`を使えば短縮することもできます。

```css
/* repeat() で6列指示 */
grid-template-columns: repeat(6, 1fr);

/*　これは、以下と同じ意味 */
grid-template-columns: 1fr 1fr 1fr 1fr 1fr 1fr;
```

Gridは「2次元レイアウト（行×列）」の調整が必要な場面に最適です。記事リスト、カード一覧、比率が決まった複数カラムなど、縦横の整列をそろえたいUIでは圧倒的に効率がよく、可読性の高いCSSが書けます。

一方、Flexは「1方向に順番に並べたい要素」が得意です。ナビゲーション、ボタン群、タグリスト、横スクロールカードなど、コンテンツ量に応じて自然に伸縮してほしい場面ではFlexがシンプルに実装できます。


## 複数要素を上下左右センター寄せする

次に、複数要素をまとめて上下左右センター寄せする実装を見てみましょう。

Flexレイアウトでは標準の並びが横方向のため、縦方向に積み上げて中央寄せしたい場合は、`flex-direction: column;`を追加する必要があります。一方、Gridレイアウトは標準で要素を「行方向（縦）」に並べるため、Flexに比べて1行分の指定が不要になり、より簡潔なコードで中央寄せを実現できます。

どちらの例でも、`place-content: center;`と`place-items: center;`を指定していますが、これらは 親グリッド（またはFlexコンテナ）内で要素を上下左右の中央に配置するショートハンド構文です。さらに、`aspect-ratio: 16/9;` を指定することで、ボックス自体を16:9の比率で保持し、見本として安定した表示エリアを作っています。

```css
/* grid */
.grid-center {
  display: grid;
  place-content: center;
  place-items: center;
  aspect-ratio: 16/9;
}

/* flex */
.flex-center {
  display: flex;
  flex-direction: column;
  place-content: center;
  place-items: center;
  aspect-ratio: 16/9;
}
```

```html
<!-- grid -->
<div class="grid-center _box_">
  <div class="font-size--lg">Center</div>
  <p>Lorem ipsum dolor sit amet.</p>
</div>

<!-- flex -->
<div class="flex-center _box_">
  <div class="font-size--lg">Center</div>
  <p>Lorem ipsum dolor sit amet.</p>
</div>
```

<iframe height="300" style="width: 100%;" scrolling="no" title="book 1- grid / flex - center" src="https://codepen.io/ddryo-the-encoder/embed/XJdmXrv/a735815b4110679a73663c99d41771e1?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true">
  See the Pen <a href="https://codepen.io/ddryo-the-encoder/pen/XJdmXrv/a735815b4110679a73663c99d41771e1">book 1- grid / flex - center</a> by ddryo (<a href="https://codepen.io/ddryo-the-encoder">@ddryo-the-encoder</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>


## 画像の上にカラーレイヤーとコンテンツを重ねて表示する

画像の上にカラーレイヤーやテキストを重ねるレイアウトは、従来 `position: absolute`で実装することが一般的でした。しかし、absoluteは中央寄せのために`top: 50%`・`left: 50%`・`translate()`を組み合わせる必要があるなど、内部要素の位置調整にどうしても手間がかかります。

一方、Grid を使った「重ね書き」なら、すべての子要素を `grid-area: 1 / 1`に配置するだけで任意のレイヤリングが実現でき、`place-self`や`margin: auto`といった配置系プロパティもそのまま利用できるため、コード量が少なく、調整もしやすいのが大きな特徴です。

```css
/* 画像に重ねる要素の共通スタイリング */
.layered-box__content {
  color: #fff;
  font-size: var(--font-size--lg);
  padding: var(--space--2);
  border-bottom: solid 1px;
}
.layered-box__blacklayer {
  background: rgb(0 0 0 / 0.5);
}

/* gridでの実装 */
.layered-box--grid {
  display: grid;
}
.layered-box--grid > * {
  grid-area: 1 / 1;
}
.layered-box--grid > .layered-box__content {
  place-self: center;
}

/* position: absolute での実装 */
.layered-box--absolute {
  position: relative;
}
.layered-box--absolute > .layered-box__blacklayer {
  position: absolute;
  inset: 0;
}
.layered-box--absolute > .layered-box__content {
  position: absolute;
  top: 50%;
  left: 50%;
  translate: -50% -50%;
  width: max-content;
  max-width: 100%;
}
```

```html
<!-- grid -->
<div class="layered-box layered-box--grid">
  <img src="https://book-cdn.pages.dev/img/img-1.jpg" alt="" width="1200" height="800">
  <div class="layered-box__blacklayer"></div>
  <div class="layered-box__content">Overlay Contents</div>
</div>

<!-- absolute -->
<div class="layered-box layered-box--absolute">
  <img src="https://book-cdn.pages.dev/img/img-1.jpg" alt="" width="1200" height="800">
  <div class="layered-box__blacklayer"></div>
  <div class="layered-box__content">Overlay Contents</div>
</div>
```

<iframe height="300" style="width: 100%;" scrolling="no" title="book 1- grid - layerd" src="https://codepen.io/ddryo-the-encoder/embed/vEGNGyQ/5dc612e133024c4f39bf9bdd70e02a2c?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true">
  See the Pen <a href="https://codepen.io/ddryo-the-encoder/pen/vEGNGyQ/5dc612e133024c4f39bf9bdd70e02a2c">book 1- grid - layerd</a> by ddryo (<a href="https://codepen.io/ddryo-the-encoder">@ddryo-the-encoder</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>


## Gridの基本的なプロパティ

Gridの便利さを体感したところで、ここからは「何をどう指定できるのか」をざっと整理しておきましょう。Gridは親「（コンテナ）の設計」と「子（アイテム）の配置指定」が完全に分離しているのが大きな特徴で、これを理解しておくと複雑なレイアウトも迷いなく組めるようになります。

### Gridを定義する（親）要素で使うプロパティ

- `grid-template-rows`: 行（↓）方向の数や高さを指定
- `grid-template-columns`: 列（→）方向の数や幅を指定
- `grid-template-areas`: グリッド上の各エリアに名前をつける
- `grid-template`: rows / columns / areas をまとめて指定（慣れるまでは個別指定でOK）

これらはgridの「設計図」を作る部分です。どこに行や列を引くか、どんな大きさかをここで決めます。

### Grid の子要素で使うプロパティ

- `grid-row-start`: 配置開始する行ラインを指定
- `grid-row-end`: 配置終了する行ラインを指定
- `grid-column-start`: 配置開始する列ラインを指定
- `grid-column-end`: 配置終了する列ラインを指定
- `grid-area`: 親で指定したエリア名で配置（areas を使うときに便利）

これらは親で作った"マス目のどこに置くか"を指示するプロパティ群です。


### Gridプロパティの一括指定

Gridのプロパティは以下のように、一括指定することもできます。

```css
grid-row: start / end
grid-column: start / end
```

`grid-row`, `grid-column`でよく使う`span`についても少し解説しておきます。これは、`span {数値}` という書き方をすることで、何個分のトラックラインを占有するかを指定できます。

例えば以下のように指定すると、開始するカラムライン番号が1で、終了するライン番号はそこから2つ先、つまり3となります。

```css
grid-colums: 1 / span 2;
```

> **1frの意味と注意点**
> 
> `grid-template-xxx`でよく見かける`1fr`は、「利用可能な空きスペースを等分した1単位」 という意味です。カラムや行の指定に`1fr 1fr ...`を指定すると、それぞれ同じサイズ配分となります。
> 
> ただし、`1fr`の計算では「その要素の最小サイズ（min-content）」が基準となるので、最小コンテンツが大きい要素（長いurl文字列など）があった場合に思ったようなサイズにならないことがあります。
> 
> これを回避するには、`minmax(0, 1fr)`を指定します。こうすることで、「最小値を 0、最大値を 1fr（利用可能な余白の等分）」にするという意味になり、想定外のレイアウト崩れを防ぐことができます。

> **spanを指定する際の注意**
> 
> start側にspanを持ってきた時と、end側にspanを持ってきた時とで、基準位置と占有方向の考え方が逆になります。`grid-colums-start:span 2;`と`grid-colums-end: span 2;`だけをそれぞれ指定した場合で、どちらも同じ2トラックを占有することとなり、挙動が同じになったりします。慣れないうちは、end方向にだけspanを指定する癖をつけると、「開始位置から何個分広がるか」という覚え方ができるので、おすすめです。


## columns / rowsを指定して要素を配置してみる

説明だけではイメージがつきにくいので、実際に 行・列トラックを作り、その上に要素を「配置していく感覚」を体験してみましょう。

以下のコードでは、親の `.grid-4x4`で4列×4行のグリッドを定義し、その上にA/B/C/Dの4つのボックスを`grid-column`と `grid-row`を使って配置します。これらのプロパティは「どのラインからどのラインまで占有するか」を指定するため、レイアウトを"マス目の席取り"のようにコントロールできるのがポイントです。

```css
.grid-4x4 {
  display: grid;
  border: dashed 1px;
  gap: var(--space--2);
  grid-template-columns: repeat(4, minmax(0, 1fr));
  grid-template-rows: repeat(4, minmax(0, 1fr));
  min-height: 400px;
}
.box-a {
  grid-column: 1 / span 2;
  grid-row: 1 / span 4;
}
.box-b {
  grid-column: 3 / span 2;
  grid-row: 1 / span 2;
}
.box-c {
  grid-column: 3;
  grid-row: 3;
}
.box-d {
  grid-column: 4;
  grid-row: 4;
}
```

```html
<div class="grid-4x4">
  <div class="_box_ box-a">A</div>
  <div class="_box_ box-b">B</div>
  <div class="_box_ box-c">C</div>
  <div class="_box_ box-d">D</div>
</div>
```

<iframe height="300" style="width: 100%;" scrolling="no" title="book 1- grid - row/column" src="https://codepen.io/ddryo-the-encoder/embed/vEGNKxO/61faa11b64f5146193c22a9b40ac75ca?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true">
  See the Pen <a href="https://codepen.io/ddryo-the-encoder/pen/vEGNKxO/61faa11b64f5146193c22a9b40ac75ca">book 1- grid - row/column</a> by ddryo (<a href="https://codepen.io/ddryo-the-encoder">@ddryo-the-encoder</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>


## 名前付きグリッドエリアを試してみる

続いて、親グリッドで`grid-template-areas`を使い、行・列トラックに「名前」を付けてレイアウトを組む方法を紹介します。名前付きエリアを使うと、どの要素をどの位置に配置したいかをテキストで直感的に表現できるため、複雑なページ構成でも分かりやすく管理できます。

ここで、768px以上での「名前の付け方」に注目してください。2カラムのレイアウトに切り替わる時、ヘッダーとフッターは横幅いっぱい（2カラム分）に広がる必要があります。そのため、`"header header"` や `"footer footer"` のように、左右のカラム両方に同じエリア名を2つ並べて記述します。

こうすることで、「headerは2カラム分をまとめて占有する」「footerも同様に横幅いっぱいに配置される」「mainとaside は横並びでそれぞれに割り当てられる」という意図を直感的に表現できるようになります。

```css
/* コンテンツエリアを名前付けしたグリッド */
.area-grid {
  display: grid;
  border: dashed 1px;
  gap: var(--space--2);
  max-width: 1200px;
  min-height: 100vh;
  margin-inline: auto;
  grid-template-areas:
    "header"
    "main"
    "aside"
    "footer";
  grid-template-rows: auto 1fr auto auto;
}
.header {
  grid-area: header;
}
.main {
  grid-area: main;
}
.aside {
  grid-area: aside;
}
.footer {
  grid-area: footer;
}
/* 広いサイズ */
@media (min-width: 768px) {
  .area-grid {
    grid-template-areas:
      "header header"
      "main aside"
      "footer footer";
    grid-template-columns: 1fr 240px;
    grid-template-rows: auto 1fr auto;
  }
}
```

```html
<div class="area-grid">
  <div class="_box_ header">
    <p>Header</p>
  </div>
  <div class="_box_ main">
    <p>Main</p>
  </div>
  <div class="_box_ aside">
    <p>Aside</p>
  </div>
  <div class="_box_ footer">
    <p>Footer</p>
  </div>
</div>
```

<iframe height="300" style="width: 100%;" scrolling="no" title="book 1- grid - areas" src="https://codepen.io/ddryo-the-encoder/embed/bNpVeYr/44a1d0086064075698423457ce2f1a11?default-tab=html%2Cresult" frameborder="no" loading="lazy" allowtransparency="true">
  See the Pen <a href="https://codepen.io/ddryo-the-encoder/pen/bNpVeYr/44a1d0086064075698423457ce2f1a11">book 1- grid - areas</a> by ddryo (<a href="https://codepen.io/ddryo-the-encoder">@ddryo-the-encoder</a>) on <a href="https://codepen.io">CodePen</a>.
</iframe>


## まとめ

- **等幅・比率カラムを直感的に指定できる**: 列幅や比率をそのまま宣言でき、計算不要で整ったカラムを組める。
- **2次元レイアウトを親だけでまとめて制御できる**: 行×列の配置を親要素から一括管理し、複雑な配置も見通しよく書ける。
- **中央寄せや重ね書きもシンプルな記述で実現できる**: place系やgrid-areaで要素の配置や重ねを簡潔に扱え、調整も容易。
